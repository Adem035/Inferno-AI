"""
Production-ready pentesting tool wrappers for Inferno-AI sandbox.

Provides high-level functions wrapping gobuster, ffuf, nmap, and other tools
with proper error handling, output parsing, and integration with KB.
"""

from typing import Dict, List, Optional, Tuple
import json
import re
import logging

logger = logging.getLogger(__name__)


def parse_gobuster_output(output: str) -> List[Dict[str, str]]:
    """
    Parse gobuster directory enumeration output.
    
    Args:
        output: Raw gobuster stdout
        
    Returns:
        List of discovered paths with status codes
        
    Example output:
        /admin                (Status: 200) [Size: 1234]
        /login                (Status: 302) [Size: 0]
    """
    discoveries = []
    
    # Pattern: /path    (Status: 200) [Size: 1234]
    pattern = r'^(/\S+)\s+\(Status: (\d+)\)(?:\s+\[Size: (\d+)\])?'
    
    for line in output.splitlines():
        match = re.match(pattern, line.strip())
        if match:
            path, status, size = match.groups()
            discoveries.append({
                'path': path,
                'status_code': int(status),
                'size': int(size) if size else None
            })
    
    return discoveries


def parse_ffuf_json(output: str) -> List[Dict[str, any]]:
    """
    Parse ffuf JSON output.
    
    Args:
        output: Raw ffuf JSON output
        
    Returns:
        List of discovered endpoints with details
    """
    try:
        data = json.loads(output)
        results = []
        
        for result in data.get('results', []):
            results.append({
                'url': result.get('url'),
                'status_code': result.get('status'),
                'length': result.get('length'),
                'words': result.get('words'),
                'lines': result.get('lines')
            })
        
        return results
        
    except json.JSONDecodeError as e:
        logger.error(f"Failed to parse ffuf JSON: {e}")
        return []


def parse_nmap_output(output: str) -> Dict[str, any]:
    """
    Parse nmap scan output.
    
    Args:
        output: Raw nmap stdout
        
    Returns:
        Dictionary with discovered ports and services
    """
    result = {
        'open_ports': [],
        'filtered_ports': [],
        'closed_ports': []
    }
    
    # Pattern: 80/tcp   open  http
    port_pattern = r'^(\d+)/(tcp|udp)\s+(open|closed|filtered)\s+(\S+)'
    
    for line in output.splitlines():
        match = re.match(port_pattern, line.strip())
        if match:
            port, protocol, state, service = match.groups()
            
            port_info = {
                'port': int(port),
                'protocol': protocol,
                'service': service
            }
            
            if state == 'open':
                result['open_ports'].append(port_info)
            elif state == 'filtered':
                result['filtered_ports'].append(port_info)
            elif state == 'closed':
                result['closed_ports'].append(port_info)
    
    return result


def build_gobuster_command(
    target_url: str,
    wordlist: str = "/usr/share/wordlists/common.txt",
    threads: int = 50,
    timeout: str = "10s",
    status_codes: str = "200,204,301,302,307,401,403,405"
) -> str:
    """
    Build gobuster directory enumeration command.
    
    Args:
        target_url: Target URL to scan
        wordlist: Path to wordlist file
        threads: Number of threads (default: 50)
        timeout: Request timeout (default: 10s)
        status_codes: Comma-separated status codes to match
        
    Returns:
        Complete gobuster command string
    """
    cmd = (
        f"gobuster dir "
        f"-u {target_url} "
        f"-w {wordlist} "
        f"-t {threads} "
        f"-b '' "  # Don't blacklist any status codes
        f"--timeout {timeout} "
        f"-q "  # Quiet mode
        f"--no-error"
    )
    
    return cmd


def build_ffuf_command(
    target_url: str,
    wordlist: str = "/usr/share/wordlists/common.txt",
    match_status: str = "200,204,301,302,307,401,403",
    threads: int = 40,
    timeout: int = 10,
    output_format: str = "json"
) -> str:
    """
    Build ffuf fuzzing command.
    
    Args:
        target_url: Target URL with FUZZ placeholder
        wordlist: Path to wordlist file
        match_status: Comma-separated status codes to match
        threads: Number of threads (default: 40)
        timeout: Request timeout in seconds (default: 10)
        output_format: Output format (json, md, csv, edn, html)
        
    Returns:
        Complete ffuf command string
        
    Example:
        target_url="http://example.com/FUZZ"
        Returns: ffuf -u http://example.com/FUZZ -w wordlist.txt -mc 200,301 -o output.json -of json
    """
    cmd = (
        f"ffuf "
        f"-u {target_url} "
        f"-w {wordlist} "
        f"-mc {match_status} "
        f"-t {threads} "
        f"-timeout {timeout} "
        f"-s "  # Silent mode
        f"-of {output_format}"
    )
    
    return cmd


def build_nmap_command(
    target_host: str,
    ports: str = "1-10000",
    scan_type: str = "-sT",  # TCP connect scan (doesn't require root)
    speed: str = "-T4",
    options: str = ""
) -> str:
    """
    Build nmap port scanning command.
    
    Args:
target_host: Target host/IP to scan
        ports: Port range (default: 1-10000)
        scan_type: Scan type (default: -sT for TCP connect)
        speed: Scan speed (default: -T4)
        options: Additional nmap options
        
    Returns:
        Complete nmap command string
    """
    cmd = (
        f"nmap "
        f"{scan_type} "
        f"{speed} "
        f"-p {ports} "
        f"{options} "
        f"{target_host}"
    )
    
    return cmd.strip()


# Tool availability checker
REQUIRED_TOOLS = {
    'curl': 'curl --version',
    'python3': 'python3 --version',
    'gobuster': 'which gobuster',
    'ffuf': 'which ffuf',
    'nmap': 'which nmap'
}


def build_tool_check_command() -> str:
    """Build command to verify all required tools are available."""
    checks = []
    for tool, cmd in REQUIRED_TOOLS.items():
        checks.append(f"echo -n '{tool}: ' && {cmd} >/dev/null 2>&1 && echo 'OK' || echo 'MISSING'")
    
    return " && ".join(checks)
